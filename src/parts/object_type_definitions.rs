#![allow(dead_code)]

#[derive(Debug, Copy, Clone, PartialEq)]
pub enum Func {
    //unary operators
    Sin,    // sin(f(x))
    Cos,    // cos(f(x))
    Tg,     // tg(f(x))
    Ctg,    // ctg(f(x))
    Ln,     // ln(f(x))
    Exp,    // e^(f(x))
    Sqrt,   // sqrt(f(x))
    Const,  // C, CeR
    Atg,  // arctg(f(x))
    Actg, // arcctg(f(x))
    Asin, // arcsin(f(x))
    Acos, // arccos(f(x))

    //These are the binary operation +, -, *, /
    Add,
    Sub,
    Mul,
    Div,
    Pow,    // g(x)^(f(x))

    //brackets
    Ob, //opne bracket
    Cb, //closed bracket

    //auxilary
    X,      //function variable
    None,   // end of the tree
}

#[derive(Debug)]
pub struct Node {
    pub first: Option<Box<Node>>,
    pub second: Option<Box<Node>>,
    pub op: Func,
    pub c: Option<f64>, //if type op = Func::Const
}

impl Node {
    pub fn new() -> Node {
        Node {
            first: None,
            second: None,
            op: Func::None,
            c: None,
        }
    }

    pub fn new_value(fun: Func, con: Option<f64>) -> Node {
        Node {
            first: None,
            second: None,
            op: fun,
            c: con,
        }
    }

    pub fn print_value(&self){
        if self.op == Func::Const {
            print!("{:?} ", match self.c {
                Some(x) => {x}
                None => {1.0}
            });
        }else{
            print!("{:?} ", self.op);
        }        
    }

    //IMPLEMENT COPY TRAIT HERE
}

pub struct Subseq {
    code: String, //complete code generated by subsequent branches
    raddr: i16,  //adress on which the result of the branches is on
}

impl Subseq {
    pub fn new(code: String, raddr: i16) -> Subseq{
        Subseq { code: code, raddr: raddr }
    }

    pub fn return_code(self) -> String {
        return self.code;
    }
}
